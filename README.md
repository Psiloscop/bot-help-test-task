# Тестовое задание от BotHelp

## Описание задачи
Есть веб-api, принимающее события (ограничимся 10000 событий) для группы аккаунтов (1000 аккаунтов) и складывающее их в очередь.
Каждое событие связано с определенным аккаунтом и важно, **чтобы события аккаунта обрабатывались в том же порядке, в котором поступили в очередь**.
Обработка события занимает 1 секунду (эмулировать с помощью `sleep`).
Сделать обработку очереди событий максимально быстрой на данной конкретной машине.
Код писать на PHP. Можно использовать фреймворки и инструменты такие как `RabbitMQ`, `Redis`, `MySQL` и т. д.

## Решение задачи
Единсвенный подход, который я вижу очевидным для решения задачи, это её распараллеливание.
Я подумал, что лучше использовать несколько очередей вместо одной и помещать аккаунты с определёнными ID в опеределённую очередь.
Каждая очередь должа обрабатываться в отдельном воркере, обеспечивая параллельность исполнения.
Для этого я сначала определил переменную окружения `MESSENGER_WORKER_COUNT` в `.env` d которой указал общее число одновременно работающих вокреров (1 воркер = 1 очередь) в проекте.
Далее эта переменная используется в `config/packages/messenger.php` для динамического определения очередей в конфигурации мессенджера.
Затем во время инициализации контейнера приложения в стартап скрипте `docker/bootstrap/bootstrap.sh` создаются `OpenRC` сервисы из шаблона `docker/openrc/symfony-worker-template`,
а после запускаются, создавая соединение в `RabbitMQ`, которые можно увидеть по ссылке http://127.0.0.1:3913/#/connections. Один `OpenRC` сервис создает только одно соединение.
Чтобы сэмулировать большой пул ивентов из условия задачи, я написал `Symfony` команду `app:event-maker`, которая создает 10000 ивентов и диспетчит их в очереди.
Выбор номера очереди для команды осуществляется по значению остатка от деленя `account_id` на `MESSENGER_WORKER_COUNT`, таким образом добиваясь последовательной обработки ивентов для каждого аккаунта.
Этот процесс происходит в сервисе `Service/AccountEventProcessDispatcher.php`. Таким образом, переменная `MESSENGER_WORKER_COUNT` определяет количество очередей, которые будут созданы в `RabbitMQ` и количество сервисов `OpenRC`,
которые запустят один воркер для обработки одной очереди.
На моей машине `MacBook Pro` с чипом `Apple M1 Pro` удалось запустить 500 очередей с их параллельной обработкой, добившись обработки всех входящих комманд за 40 секунд.

## Состав
Проект представляет собой сборку из докер образов, аккамулированных в `docker-compose.yml`.
В составе:
1. Symfony 7.1 app на базе ` php:8.3-cli-alpine`. Также в этом контейнере работает `OpenRC` для запуска Симфони воркеров.
2. RabbitMQ.

## Эндпоинты
### http://127.0.0.1:3910/api
API приложение, через который предполагается приём данных об ивенте аккаунта. Принимает только `POST` запрос с обязательными параметрами `account_id` и `event_id`

### http://127.0.0.1:3813
Url дешборда `RabbitMQ`. Детали: `guest`/`guest`

## Испорльзование
1. Открыть консоль в корне проекта и выполнить `make init`. Эта комманда выполнить установку и инициализацию всех компонентов проекта. После сообщения в консоли "Project initialized!" можно следовать дальнейшим шагам.
2. Открыть дешборд по ссылке http://127.0.0.1:3913/#/queues, в которой будут отображены созданные очереди.
3. Выполнить комманду `php bin/console app:event-maker` для создания 10000 ивентов со сгенерированными `account_id` и `event_id`.
У комманды есть две опции: `--event-amount` для указания количества ивентов для генерации и `--max-account-id` для указания максимального `account-id` (по умолсению 1000).
4. Наблюдать параллельную обработку очерелей из пункта 2.

